# README of module GET_IDLV.py

Compute the lexical availavility score form texts.

`get_idlv.``get_indices`(*sample*, *resolution*, *dict_words_arrayindex*, *stats*)

Given a sample text, update the matrix (vocabulary x indices) and
 the stats dictionary that are useful to compute the IDLV values

<table frame="void" class="docutils field-list"><colgroup><col class="field-name"> <col class="field-body"></colgroup><tbody valign="top"><tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils"><dt><strong>sample</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt><dd><span>Each token to analyze is separated by a single space</span></dd><dt><strong>resolution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt><dd><span>The maximum number of slots or indices in this<span class="ag-soft-line-break"></span> _sample_. If _resolution_ == 1 then absolute positions are consider <span class="ag-soft-line-break"></span>(a.k.a. the length of _sample_); if _resolution_ &gt; 1 then the <span class="ag-soft-line-break"></span>_sample_ is divided into _resolution_ parts and each part corresponds to<span class="ag-soft-line-break"></span> a position (then, total positions for this _sample_ is _resolution_)</span></dd><dt><strong>dict_words_arrayindex</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary of dictionaries</span></dt><dd><span>Store the entire vocabulary and is been <span class="ag-soft-line-break"></span>updated while samples are read. Where key = word and value = an array of<span class="ag-soft-line-break"></span> indices and frecuency of this word in that index.</span></dd><dt><strong>stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary of dictionaries</span></dt><dd><span>wWth 2 main keys: ‘last_position’ and <span class="ag-soft-line-break"></span>‘frequency’ each of those has a dictionary with key=word and <span class="ag-soft-line-break"></span>value=last_position or frequency, of this word in the corpus.</span></dd><dt><strong>Returns</strong></dt><dd></dd><dt><strong>——-</strong></dt><dd></dd><dt><strong>my_dict</strong></dt><dd><span>same input dictionary but updated</span></dd><dt><strong>stats</strong></dt><dd><span>same input dictionary but updated</span></dd></dl></td></tr></tbody></table>

`get_idlv.``main`(*dir_in*, *dir_out*, *resolution*)

Main function for a set of classes of samples. This will call main_idlv funtion for each different class.

<table frame="void" class="docutils field-list"><colgroup><col class="field-name"> <col class="field-body"></colgroup><tbody valign="top"><tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils"><dt><strong>dir_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt><dd><span>The path that contain N files, each file with one set of samples. For each file in dir_in a idlv_list will be computed</span></dd><dt><strong>dir_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt><dd><span>The path where each list will be written</span></dd><dt><strong>resolution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt><dd><span>Specify the maximum number of positions <span class="ag-soft-line-break"></span>allowed, if == 1 then consider absolute positions of words in the texts;<span class="ag-soft-line-break"></span> if &gt; 1 then divide the text in that many parts, each part then is <span class="ag-soft-line-break"></span>considere a position. Parameter needed to compute IDLV values.</span></dd></dl></td></tr></tbody></table>

`get_idlv.``main_idlv`(*samples*, *resolution*, *fout*, *normalization='max_global'*, *max_features=None*, *by_instance=False*)

Main function to compute an idlv list given a set of texts. The main goal of this function is to build the
IDLV lists of each category from the input files that exist within the input directory

<table frame="void" class="docutils field-list"><colgroup><col class="field-name"> <col class="field-body"></colgroup><tbody valign="top"><tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils"><dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of strings</span></dt><dd><span>Each row in _samples_ is a single instance. <span class="ag-soft-line-break"></span>Each item in an instance is separated as a single space (items are <span class="ag-soft-line-break"></span>called words in this script, but can be n-gramas or others (e.g. <span class="ag-soft-line-break"></span>“the_cow cow_is is_blak” - in this example, there are 3 items and each <span class="ag-soft-line-break"></span>one treated as a word)</span></dd><dt><strong>resolution</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt><dd><span>Specify the maximum number of positions <span class="ag-soft-line-break"></span>allowed, if == 1 then consider absolute positions of words in the texts;<span class="ag-soft-line-break"></span> if &gt; 1 then divide the text in that many parts, each part then is <span class="ag-soft-line-break"></span>considere a position</span></dd><dt><strong>fout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt><dd><span>A file name (complete path otherwise is written in the current directory) where the list for this _samples_ will be written</span></dd><dt><strong>normalization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt><dd><span>The type of normalization used when computing IDLV score: can be “max_global” or “max_word”. (default is “max_global”)</span></dd><dt><strong>max_features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer , optional</span></dt><dd><span>Specify how many item in the list to be <span class="ag-soft-line-break"></span>considered (the top max_features with higher score) (default is None <span class="ag-soft-line-break"></span>meaning keep everything)</span></dd><dt><strong>by_instance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt><dd><span>Specify if _samples_ has several samples or <span class="ag-soft-line-break"></span>only one. If by_instance==False, consider several samples; otherwise is <span class="ag-soft-line-break"></span>only one sample. (default is False)</span></dd></dl></td></tr><tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils"><dt>mylist_tup</dt><dd><span>An array of tuples [(key, value), (key, value),…] where key is a word in the vocabulary and value its idlv score</span></dd></dl></td></tr></tbody></table>

`get_idlv.``update_dictionary`(*my_dict*, *stats*, *index*, *word*)

Update a dictionary to store all information needed for computing IDVL values

Given a word and the actual position of that word in a given list 
(text) update my_dict (a dictionary of vocabulary x indices ); 
Additionally, this function updates at the same time 
stats[‘last_position’] needed when computing the IDLV value; and 
stats[‘frequency’] thtat is the total number of times this word appers 
in this class (set of documents).

<table frame="void" class="docutils field-list"><colgroup><col class="field-name"> <col class="field-body"></colgroup><tbody valign="top"><tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils"><dt><strong>my_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary of dictionaries</span></dt><dd><span>To be updated each time is called this <span class="ag-soft-line-break"></span>function, where key = word and value = an array of indices and frecuency<span class="ag-soft-line-break"></span> of this word in that index</span></dd><dt><strong>stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary of dictionaries</span></dt><dd><span>With 2 main keys: ‘last_position’ and <span class="ag-soft-line-break"></span>‘frequency’ each of those has a dictionary with key=word and <span class="ag-soft-line-break"></span>value=last_position or frequency, of this word in the corpus.</span></dd><dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt><dd><span>States the current position of this word in a given text.</span></dd><dt><strong>word</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt><dd><span>The word to be added to the dictionary or to be updated</span></dd></dl></td></tr><tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils"><dt>my_dict</dt><dd><span>same input dictionary but updated</span></dd><dt>stats</dt><dd><span>same input dictionary but updated</span></dd></dl></td></tr></tbody></table>

Powered by [Sphinx 1.8.5](http://sphinx-doc.org/) & [Alabaster 0.7.12](https://github.com/bitprophet/alabaster)
